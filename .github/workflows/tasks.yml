name: Tasks IssueOps

on:
  issue_comment:
    types: [created, edited]
  workflow_dispatch: {}

# √âvite les collisions si plusieurs commentaires arrivent en m√™me temps sur la m√™me issue
concurrency:
  group: tasks-issueops-${{ github.event.issue.number || github.ref }}
  cancel-in-progress: false

permissions:
  contents: read
  issues: write

env:
  # Mention √† utiliser dans les commentaires
  BOT_HANDLE: "@bot"

  # Base URL + token (d√©j√† configur√©s dans vos Secrets)
  TASKS_BASE_URL: ${{ secrets.TASKS_BASE_URL }}
  TASKS_API_TOKEN: ${{ secrets.TASKS_API_TOKEN }}

  # Chemins d'API AJUSTABLES selon votre service Flask (laisser tels quels si REST classique)
  TASKS_LIST_PATH: "/tasks"
  TASKS_ADD_PATH: "/tasks"
  TASKS_DONE_PATH: "/tasks/{id}"         # PATCH avec {"status":"done"} (ou ajustez p.ex. "/tasks/{id}/complete")
  TASKS_DELETE_PATH: "/tasks/{id}"       # DELETE

jobs:
  issueops:
    name: Parse comment and call Tasks API
    runs-on: ubuntu-latest

    # Ne s'ex√©cute que si le commentaire contient la mention du bot
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' &&
       contains(github.event.comment.body, env.BOT_HANDLE))

    steps:
      - name: V√©rifications de base
        run: |
          test -n "${TASKS_BASE_URL}" || (echo "‚ùå TASKS_BASE_URL manquant (Secret)" && exit 1)
          test -n "${TASKS_API_TOKEN}" || (echo "‚ùå TASKS_API_TOKEN manquant (Secret)" && exit 1)

      - name: IssueOps via github-script
        uses: actions/github-script@v7
        env:
          GH_ISSUE_NUMBER: ${{ github.event.issue.number }}
          GH_REPO: ${{ github.repository }}
          GH_COMMENT_BODY: ${{ github.event.comment.body }}
          GH_COMMENT_ID: ${{ github.event.comment.id }}
          GH_ACTOR: ${{ github.actor }}
        with:
          script: |
            const core = require('@actions/core');

            // -------- Helpers
            const BOT_HANDLE = process.env.BOT_HANDLE || "@bot";
            const BASE = process.env.TASKS_BASE_URL.replace(/\/+$/, ""); // trim trailing slash
            const TOKEN = process.env.TASKS_API_TOKEN;

            // Endpoints configurables
            const PATHS = {
              list:  process.env.TASKS_LIST_PATH  || "/tasks",
              add:   process.env.TASKS_ADD_PATH   || "/tasks",
              done:  process.env.TASKS_DONE_PATH  || "/tasks/{id}",
              del:   process.env.TASKS_DELETE_PATH|| "/tasks/{id}",
            };

            const issueNumber = process.env.GH_ISSUE_NUMBER || (context.payload.issue && context.payload.issue.number);
            const issueUrl = context.payload.issue && context.payload.issue.html_url;
            const repo = process.env.GH_REPO || `${context.repo.owner}/${context.repo.repo}`;
            const commentBody = process.env.GH_COMMENT_BODY || "";

            // Utilitaires HTTP
            async function apiFetch(path, opts = {}) {
              const url = `${BASE}${path}`;
              const headers = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${TOKEN}`,
                // Optionnel : laissez si votre backend supporte aussi ce header
                'X-API-Token': TOKEN,
                ...(opts.headers || {})
              };
              const res = await fetch(url, { ...opts, headers });
              let data = null;
              const text = await res.text();
              try { data = text ? JSON.parse(text) : null; } catch { data = text; }
              if (!res.ok) {
                const msg = `HTTP ${res.status} ${res.statusText} -> ${url}\n${text}`;
                throw new Error(msg);
              }
              return data;
            }

            function mdEscape(s='') {
              return String(s).replace(/([\\`*_{}[\]()#+\-.!|>])/g, '\\$1');
            }

            function formatTasksList(tasks) {
              if (!Array.isArray(tasks) || tasks.length === 0) return "_Aucune t√¢che._";
              // Normalise diverses structures possibles : [{id,title,completed|status}]
              return tasks.map(t => {
                const id = t.id ?? t._id ?? t.uuid ?? "?";
                const title = t.title ?? t.name ?? t.label ?? "(sans titre)";
                const done = typeof t.completed === 'boolean' ? t.completed
                           : (typeof t.status === 'string' ? t.status.toLowerCase() === 'done' : false);
                const box = done ? "‚òëÔ∏é" : "‚òê";
                return `- ${box} **#${id}** ‚Äî ${mdEscape(title)}`;
              }).join("\n");
            }

            async function getTasks() {
              return apiFetch(PATHS.list, { method: 'GET' });
            }

            async function findTaskId(arg) {
              // Si arg est un ID num√©rique/UUID -> retourne tel quel
              if (!arg) return null;
              const idLike = arg.trim().replace(/^#/, '');
              // heuristique simple : si tout est chiffres, supposez ID
              if (/^[0-9]+$/.test(idLike) || /^[0-9a-f-]{6,}$/i.test(idLike)) {
                return idLike;
              }
              // Sinon, chercher par titre (exact / insensible √† la casse)
              const tasks = await getTasks();
              const lower = idLike.replace(/^"|"$/g, '').toLowerCase();
              const found = Array.isArray(tasks) ? tasks.find(t => {
                const title = (t.title ?? t.name ?? '').toLowerCase();
                return title === lower;
              }) : null;
              return found ? (found.id ?? found._id ?? found.uuid) : null;
            }

            async function addTask(title) {
              const payload = {
                title: title,
                source: 'github',
                metadata: {
                  issue_url: issueUrl,
                  repository: repo,
                  actor: process.env.GH_ACTOR
                }
              };
              return apiFetch(PATHS.add, { method: 'POST', body: JSON.stringify(payload) });
            }

            async function completeTask(id) {
              if (PATHS.done.includes('{id}')) {
                const path = PATHS.done.replace('{id}', encodeURIComponent(id));
                // Essayez PATCH status: done
                try {
                  return await apiFetch(path, { method: 'PATCH', body: JSON.stringify({ status: 'done' }) });
                } catch (e) {
                  core.info(`PATCH status failed, trying POST complete: ${e.message}`);
                  // En fallback, POST sans body
                  return await apiFetch(path, { method: 'POST' });
                }
              } else {
                // Si votre API exige un autre endpoint statique
                return apiFetch(PATHS.done, { method: 'POST', body: JSON.stringify({ id, status: 'done' }) });
              }
            }

            async function deleteTask(id) {
              if (PATHS.del.includes('{id}')) {
                const path = PATHS.del.replace('{id}', encodeURIComponent(id));
                return apiFetch(path, { method: 'DELETE' });
              } else {
                return apiFetch(PATHS.del, { method: 'DELETE', body: JSON.stringify({ id }) });
              }
            }

            function parseCommand(raw) {
              // Cherche @bot <cmd> ...
              const re = new RegExp(`${BOT_HANDLE.replace('@','@')}\\s+(\\w+)([\\s\\S]*)`, 'i');
              const m = raw.match(re);
              if (!m) return null;
              const cmd = (m[1] || '').toLowerCase();
              const rest = (m[2] || '').trim();

              // Pour add, privil√©gie un titre entre guillemets "..."
              let title = null;
              const q = rest.match(/"([^"]+)"/);
              if (q) title = q[1].trim();
              else if (cmd === 'add' && rest) title = rest;

              // Pour done/delete, on prend soit un id (#123) soit "titre"
              let target = null;
              if (cmd === 'done' || cmd === 'delete') {
                const mId = rest.match(/#?([0-9a-f-]{1,})/i);
                const mQuoted = rest.match(/"([^"]+)"/);
                if (mQuoted) target = `"${mQuoted[1].trim()}"`;
                else if (mId) target = mId[1];
                else target = rest;
              }

              return { cmd, title, rest, target };
            }

            async function commentReply(body) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(issueNumber),
                body
              });
            }

            // -------- Main
            try {
              // Si d√©clench√© manuellement, d√©mo "help"
              const raw = context.eventName === 'workflow_dispatch'
                ? `${BOT_HANDLE} help`
                : (commentBody || '');

              const parsed = parseCommand(raw);
              if (!parsed) {
                core.info("No recognizable command after bot handle.");
                return;
              }

              const { cmd, title, target } = parsed;

              if (cmd === 'help') {
                await commentReply([
                  "ü§ñ **IssueOps ‚Äî commandes disponibles :**",
                  "",
                  `- \`${BOT_HANDLE} add "Titre de la t√¢che"\``,
                  `- \`${BOT_HANDLE} list\``,
                  `- \`${BOT_HANDLE} done <#id | "titre">\``,
                  `- \`${BOT_HANDLE} delete <#id | "titre">\``,
                  "",
                  "_Astuce : les chemins d‚ÄôAPI peuvent √™tre ajust√©s via les variables d‚Äôenvironnement du workflow._"
                ].join("\n"));
                return;
              }

              if (cmd === 'list') {
                const tasks = await getTasks();
                await commentReply(`üóíÔ∏è **T√¢ches actuelles**\n\n${formatTasksList(tasks)}`);
                return;
              }

              if (cmd === 'add') {
                if (!title) {
                  await commentReply(`‚ö†Ô∏è Usage : \`${BOT_HANDLE} add "Titre de la t√¢che"\``);
                  return;
                }
                const created = await addTask(title);
                const id = created?.id ?? created?._id ?? created?.uuid ?? "?";
                await commentReply(`‚úÖ T√¢che ajout√©e : **#${id}** ‚Äî ${mdEscape(title)}`);
                return;
              }

              if (cmd === 'done' || cmd === 'complete') {
                if (!target) {
                  await commentReply(`‚ö†Ô∏è Usage : \`${BOT_HANDLE} done <#id | "titre">\``);
                  return;
                }
                const id = await findTaskId(target);
                if (!id) {
                  await commentReply(`‚ùå Impossible de trouver la t√¢che cible \`${mdEscape(target)}\`.`);
                  return;
                }
                await completeTask(id);
                await commentReply(`üéâ T√¢che **#${id}** marqu√©e comme *done*.`);
                return;
              }

              if (cmd === 'delete' || cmd === 'remove' || cmd === 'del') {
                if (!target) {
                  await commentReply(`‚ö†Ô∏è Usage : \`${BOT_HANDLE} delete <#id | "titre">\``);
                  return;
                }
                const id = await findTaskId(target);
                if (!id) {
                  await commentReply(`‚ùå Impossible de trouver la t√¢che cible \`${mdEscape(target)}\`.`);
                  return;
                }
                await deleteTask(id);
                await commentReply(`üóëÔ∏è T√¢che **#${id}** supprim√©e.`);
                return;
              }

              await commentReply(`ü§∑ Commande inconnue. Essayez \`${BOT_HANDLE} help\`.`);

            } catch (error) {
              core.warning(error.stack || String(error));
              const msg = error.message ? `\n\n\`\`\`\n${error.message.substring(0, 4000)}\n\`\`\`` : '';
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(process.env.GH_ISSUE_NUMBER),
                body: `‚ùå **Erreur IssueOps**${msg}\n_V√©rifiez les Secrets/URLs et les chemins d‚ÄôAPI dans le workflow._`
              });
              throw error;
            }
