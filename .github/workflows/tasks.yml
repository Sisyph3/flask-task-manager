name: Tasks IssueOps

on:
  issue_comment:
    types: [created, edited]
  workflow_dispatch:

concurrency:
  group: tasks-issueops-${{ github.event.issue.number || github.run_id }}
  cancel-in-progress: false

permissions:
  contents: read
  issues: write

env:
  BOT_HANDLE: "@bot"
  TASKS_BASE_URL: ${{ secrets.TASKS_BASE_URL }}
  TASKS_API_TOKEN: ${{ secrets.TASKS_API_TOKEN }}
  TASKS_LIST_PATH: "/tasks"
  TASKS_ADD_PATH: "/tasks"
  TASKS_DONE_PATH: "/tasks/{id}"
  TASKS_DELETE_PATH: "/tasks/{id}"

jobs:
  issueops:
    name: Parse comment and call Tasks API
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'issue_comment' || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: V√©rifications de base
        run: |
          test -n "${TASKS_BASE_URL}" || (echo "‚ùå TASKS_BASE_URL manquant (Secret)" && exit 1)
          test -n "${TASKS_API_TOKEN}" || (echo "‚ùå TASKS_API_TOKEN manquant (Secret)" && exit 1)

      - name: IssueOps via github-script
        uses: actions/github-script@v7
        env:
          GH_ISSUE_NUMBER: ${{ github.event.issue.number }}
          GH_REPO: ${{ github.repository }}
          GH_COMMENT_BODY: ${{ github.event.comment.body }}
          GH_COMMENT_ID: ${{ github.event.comment.id }}
          GH_ACTOR: ${{ github.actor }}
        with:
          script: |
            // ‚¨ÖÔ∏è NE PAS re-d√©clarer `core`, `github`, `context` (d√©j√† inject√©s par github-script)

            // -------- Config
            const BOT_HANDLE = process.env.BOT_HANDLE || "@bot";
            const BASE = (process.env.TASKS_BASE_URL || "").replace(/\/+$/, "");
            const TOKEN = process.env.TASKS_API_TOKEN;

            const PATHS = {
              list:  process.env.TASKS_LIST_PATH  || "/tasks",
              add:   process.env.TASKS_ADD_PATH   || "/tasks",
              done:  process.env.TASKS_DONE_PATH  || "/tasks/{id}",
              del:   process.env.TASKS_DELETE_PATH|| "/tasks/{id}",
            };

            const issueNumber = process.env.GH_ISSUE_NUMBER || (context.payload.issue && context.payload.issue.number);
            const issueUrl = context.payload.issue && context.payload.issue.html_url;
            const repo = process.env.GH_REPO || `${context.repo.owner}/${context.repo.repo}`;
            const commentBody = process.env.GH_COMMENT_BODY || "";
            const hasIssue = !!issueNumber;

            // -------- HTTP util
            async function apiFetch(path, opts = {}) {
              if (!BASE) throw new Error("TASKS_BASE_URL manquant.");
              const url = `${BASE}${path}`;
              const headers = {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${TOKEN}`,
                "X-API-Token": TOKEN,
                ...(opts.headers || {})
              };
              const res = await fetch(url, { ...opts, headers });
              const text = await res.text();
              let data = null;
              try { data = text ? JSON.parse(text) : null; } catch { data = text; }
              if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} -> ${url}\n${text}`);
              return data;
            }

            // -------- Helpers
            function mdEscape(s='') {
              return String(s).replace(/([\\`*_{}[\\]()#+\\-.!|>])/g, '\\$1');
            }

            function formatTasksList(tasks) {
              if (!Array.isArray(tasks) || tasks.length === 0) return "_Aucune t√¢che._";
              return tasks.map(t => {
                const id = t.id ?? t._id ?? t.uuid ?? "?";
                const title = t.title ?? t.name ?? t.label ?? "(sans titre)";
                const done = typeof t.completed === 'boolean' ? t.completed
                           : (typeof t.status === 'string' ? t.status.toLowerCase() === 'done' : false);
                const box = done ? "‚òëÔ∏é" : "‚òê";
                return `- ${box} **#${id}** ‚Äî ${mdEscape(title)}`;
              }).join("\n");
            }

            async function getTasks() { return apiFetch(PATHS.list, { method: "GET" }); }
            async function addTask(title) {
              const payload = { title, source: "github", metadata: { issue_url: issueUrl, repository: repo, actor: process.env.GH_ACTOR } };
              return apiFetch(PATHS.add, { method: "POST", body: JSON.stringify(payload) });
            }
            async function completeTask(id) {
              if (PATHS.done.includes("{id}")) {
                const path = PATHS.done.replace("{id}", encodeURIComponent(id));
                try { return await apiFetch(path, { method: "PATCH", body: JSON.stringify({ status: "done" }) }); }
                catch { return apiFetch(path, { method: "POST" }); }
              } else {
                return apiFetch(PATHS.done, { method: "POST", body: JSON.stringify({ id, status: "done" }) });
              }
            }
            async function deleteTask(id) {
              if (PATHS.del.includes("{id}")) {
                const path = PATHS.del.replace("{id}", encodeURIComponent(id));
                return apiFetch(path, { method: "DELETE" });
              } else {
                return apiFetch(PATHS.del, { method: "DELETE", body: JSON.stringify({ id }) });
              }
            }
            async function findTaskId(arg) {
              if (!arg) return null;
              const idLike = arg.trim().replace(/^#/, "");
              if (/^[0-9]+$/.test(idLike) || /^[0-9a-f-]{6,}$/i.test(idLike)) return idLike;
              const tasks = await getTasks();
              const lower = idLike.replace(/^"|"$/g, "").toLowerCase();
              const found = Array.isArray(tasks) ? tasks.find(t => ((t.title ?? t.name ?? "").toLowerCase() === lower)) : null;
              return found ? (found.id ?? found._id ?? found.uuid) : null;
            }

            function parseCommand(raw) {
              const mention = BOT_HANDLE.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const re = new RegExp(`${mention}\\s+(\\w+)([\\s\\S]*)`, "i");
              const m = raw.match(re);
              if (!m) return null;
              const cmd = (m[1] || "").toLowerCase();
              const rest = (m[2] || "").trim();

              let title = null;
              const q = rest.match(/"([^"]+)"/);
              if (q) title = q[1].trim();
              else if (cmd === "add" && rest) title = rest;

              let target = null;
              if (cmd === "done" || cmd === "delete") {
                const mId = rest.match(/#?([0-9a-f-]{1,})/i);
                const mQuoted = rest.match(/"([^"]+)"/);
                if (mQuoted) target = `"${mQuoted[1].trim()}"`;
                else if (mId) target = mId[1];
                else target = rest;
              }
              return { cmd, title, rest, target };
            }

            async function commentReply(body) {
              if (!hasIssue) { core.info("No issue context; skipping comment: " + body); return; }
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(issueNumber),
                body
              });
            }

            // -------- Main
            try {
              const parsed = parseCommand(commentBody);
              if (!parsed) { core.info("No @bot command detected. Skipping."); return; }

              const { cmd, title, target } = parsed;

              if (cmd === "help") {
                await commentReply([
                  "ü§ñ **IssueOps ‚Äî commandes disponibles :**",
                  "",
                  `- \`${BOT_HANDLE} add "Titre de la t√¢che"\``,
                  `- \`${BOT_HANDLE} list\``,
                  `- \`${BOT_HANDLE} done <#id | "titre">\``,
                  `- \`${BOT_HANDLE} delete <#id | "titre">\``,
                  "",
                  "_Astuce : ajustez les chemins via les variables d‚Äôenvironnement du workflow._"
                ].join("\n"));
                return;
              }

              if (cmd === "list") {
                const tasks = await getTasks();
                await commentReply(`üóíÔ∏è **T√¢ches actuelles**\n\n${formatTasksList(tasks)}`);
                return;
              }

              if (cmd === "add") {
                if (!title) { await commentReply(`‚ö†Ô∏è Usage : \`${BOT_HANDLE} add "Titre de la t√¢che"\``); return; }
                const created = await addTask(title);
                const id = created?.id ?? created?._id ?? created?.uuid ?? "?";
                await commentReply(`‚úÖ T√¢che ajout√©e : **#${id}** ‚Äî ${mdEscape(title)}`);
                return;
              }

              if (cmd === "done" || cmd === "complete") {
                if (!target) { await commentReply(`‚ö†Ô∏è Usage : \`${BOT_HANDLE} done <#id | "titre">\``); return; }
                const id = await findTaskId(target);
                if (!id) { await commentReply(`‚ùå Impossible de trouver la t√¢che cible \`${mdEscape(target)}\`.`); return; }
                await completeTask(id);
                await commentReply(`üéâ T√¢che **#${id}** marqu√©e comme *done*.`);
                return;
              }

              if (cmd === "delete" || cmd === "remove" || cmd === "del") {
                if (!target) { await commentReply(`‚ö†Ô∏è Usage : \`${BOT_HANDLE} delete <#id | "titre">\``); return; }
                const id = await findTaskId(target);
                if (!id) { await commentReply(`‚ùå Impossible de trouver la t√¢che cible \`${mdEscape(target)}\`.`); return; }
                await deleteTask(id);
                await commentReply(`üóëÔ∏è T√¢che **#${id}** supprim√©e.`);
                return;
              }

              await commentReply(`ü§∑ Commande inconnue. Essayez \`${BOT_HANDLE} help\`.`);

            } catch (error) {
              core.warning(error.stack || String(error));
              const msg = error.message ? `\n\n\`\`\`\n${error.message.substring(0, 4000)}\n\`\`\`` : "";
              await commentReply(`‚ùå **Erreur IssueOps**${msg}\n_V√©rifiez les Secrets/URLs et les chemins d‚ÄôAPI._`);
              throw error;
            }
